FuseBox.pkg("fuse-react", {"path-to-regexp":"2.4.0"}, function(___scope___){
___scope___.file("index.js", function(exports, require, module, __filename, __dirname){

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Route_1 = require("./Router/Route");
exports.Route = Route_1.Route;
exports.navigate = Route_1.navigate;
exports.mergeQuery = Route_1.mergeQuery;
exports.setQuery = Route_1.setQuery;
var Link_1 = require("./Router/Link");
exports.Link = Link_1.Link;
var Switch_1 = require("./Router/Switch");
exports.Switch = Switch_1.Switch;
var Store_1 = require("./Store");
exports.connect = Store_1.connect;
exports.dispatch = Store_1.dispatch;
exports.getStore = Store_1.getStore;
exports.createStore = Store_1.createStore;
var Query_1 = require("./Query");
exports.Query = Query_1.Query;
var Fusion_1 = require("./Fusion");
exports.Fusion = Fusion_1.Fusion;
var Utils_1 = require("./Utils");
exports.cls = Utils_1.cls;
exports.classProp = Utils_1.classProp;

});
___scope___.file("Router/Route.js", function(exports, require, module, __filename, __dirname){

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Fusion_1 = require("../Fusion");
const Store_1 = require("../Store");
const Query_1 = require("../Query");
function navigate(path, query) {
    if (query) {
        path = `${path}${Query_1.Query.createString(query)}`;
    }
    window.history.pushState({}, "", path);
    Store_1.dispatch("router", () => ({
        location: path,
        query: Query_1.Query.get()
    }));
}
exports.navigate = navigate;
function mergeQuery(query, doDispatch = true) {
    const data = Query_1.Query.merge(query);
    const path = `${location.pathname}${data.str}`;
    window.history.pushState({}, "", path);
    if (doDispatch) {
        Store_1.dispatch("router", () => ({
            location: location.pathname,
            query: Query_1.Query.get()
        }));
    }
}
exports.mergeQuery = mergeQuery;
function setQuery(query, doDispatch = true) {
    const data = Query_1.Query.createString(query);
    const path = `${location.pathname}${data}`;
    window.history.pushState({}, "", path);
    if (doDispatch) {
        Store_1.dispatch("router", () => ({
            location: location.pathname,
            query: Query_1.Query.get()
        }));
    }
}
exports.setQuery = setQuery;
class Route extends Fusion_1.Fusion {
    render() {
        return this.props.children;
    }
}
exports.Route = Route;

});
___scope___.file("Fusion.js", function(exports, require, module, __filename, __dirname){

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const React = require("react");
const Store_1 = require("./Store");
const equal = require("deep-equal");
const Subscriptions = Store_1.getSubscriptions();
class Fusion extends React.Component {
    constructor() {
        super(...arguments);
        this.state = {};
        this.store = Store_1.getStore();
        this.isComponentMounted = false;
    }
    _hasSubscriptions(obj) {
        const subscriptions = this.getConnectedStoreKeys();
        const store = Store_1.getStore();
        if (subscriptions) {
            for (const key in obj) {
                const hasSubscription = subscriptions[key];
                if (hasSubscription) {
                    if (!hasSubscription.deep) {
                        return true;
                    }
                    if (hasSubscription.deep && !equal(store[key], obj[key])) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    getConnectedStoreKeys() {
        return this.constructor["$_connected_store_props"] || {};
    }
    _initialize() {
        if (typeof this["init"] === "function") {
            this["init"].apply(this, [this.props]);
            return true;
        }
        return false;
    }
    componentWillMount() {
        this.isComponentMounted = true;
        const keys = this.getConnectedStoreKeys();
        if (Object.keys(keys).length) {
            Subscriptions.push(this);
        }
        this._initialize();
    }
    componentWillUnmount() {
        this.isComponentMounted = false;
        const index = Subscriptions.indexOf(this);
        if (index > -1) {
            Subscriptions.splice(index, 1);
        }
    }
    componentWillReceiveProps(newProps) {
        this.props = newProps;
        this._initialize();
    }
}
exports.Fusion = Fusion;

});
___scope___.file("Store.js", function(exports, require, module, __filename, __dirname){

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Init_1 = require("./Router/Init");
function contextWithDefaultValues(obj) {
    obj["initial"] = true;
    obj["router"] = Init_1.getRouterObject();
    return obj;
}
exports.Context = contextWithDefaultValues({});
exports.Wrapper = {};
const storage = typeof window === "object" ? window : global;
storage.__Subscriptions = [];
class StoreWrapper {
    constructor(store) {
        this.store = store;
        this.listeners = {};
    }
    susbcribe(key, fn) {
        if (!this.listeners[key]) {
            this.listeners[key] = [];
        }
        this.listeners[key].push(fn);
    }
    trigger(updates) {
        for (const key in updates) {
            if (this.listeners[key]) {
                this.listeners[key].forEach(fn => {
                    fn(updates[key]);
                });
            }
        }
    }
}
exports.StoreWrapper = StoreWrapper;
function createStore(myClassContext) {
    exports.Context = contextWithDefaultValues(new myClassContext());
    if (typeof exports.Context["init"] === "function") {
        exports.Context["init"]();
    }
    exports.Wrapper = new StoreWrapper(exports.Context);
    return exports.Wrapper;
}
exports.createStore = createStore;
function getStore() {
    return exports.Context;
}
exports.getStore = getStore;
function getSubscriptions() {
    return storage.__Subscriptions;
}
exports.getSubscriptions = getSubscriptions;
function isComponentRequiredToUpdate(currentComponent, createdComponents) {
    // enable this features only in _reactInternalFiber available
    if (!currentComponent._reactInternalFiber || !currentComponent._reactInternalFiber._debugOwner) {
        return true;
    }
    let parent = currentComponent._reactInternalFiber._debugOwner.stateNode;
    while (parent) {
        if (parent._reactInternalFiber._debugOwner) {
            parent = parent._reactInternalFiber._debugOwner.stateNode;
        }
        else {
            parent = null;
        }
        if (createdComponents.find(created => created === parent)) {
            return false;
        }
    }
    return true;
}
function dispatch(obj, value) {
    const Subscriptions = storage.__Subscriptions;
    const store = getStore();
    let updates = obj;
    if (typeof obj === "object") {
        for (const key in obj) {
            if (typeof obj[key] === "function") {
                updates[key] = obj[key](store);
            }
            else {
                updates[key] = obj[key];
            }
        }
    }
    if (typeof obj === "string" && value) {
        updates = {};
        updates[obj] = value(store[obj]);
    }
    exports.Wrapper && exports.Wrapper.trigger && exports.Wrapper.trigger(updates);
    const componentsForUpdate = [];
    Subscriptions.forEach(component => {
        if (component._hasSubscriptions(updates)) {
            componentsForUpdate.push(component);
        }
    });
    for (const key in updates) {
        store[key] = updates[key];
    }
    let updatedComponents = [];
    componentsForUpdate.forEach(item => {
        if (item.isComponentMounted) {
            let updateRequired = true;
            if (updatedComponents.length) {
                updateRequired = isComponentRequiredToUpdate(item, updatedComponents);
            }
            if (updateRequired) {
                item._initialize();
                item.forceUpdate();
                updatedComponents.push(item);
            }
        }
    });
}
exports.dispatch = dispatch;
function connect(...args) {
    return (Target) => {
        if (args.length) {
            const collection = {};
            for (const i in args) {
                if (args.hasOwnProperty(i)) {
                    let key = args[i];
                    let deepEqual = false;
                    if (key[0] === "@") {
                        key = key.slice(1);
                        deepEqual = true;
                    }
                    collection[key] = { deep: deepEqual };
                }
            }
            Target["$_connected_store_props"] = collection;
        }
        return Target;
    };
}
exports.connect = connect;
// reset initial load to false
setTimeout(() => {
    dispatch("initial", () => false);
}, 0);

});
___scope___.file("Router/Init.js", function(exports, require, module, __filename, __dirname){

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Query_1 = require("../Query");
const Store_1 = require("../Store");
function updateStoreBrowserHistory() {
    setTimeout(() => {
        Store_1.dispatch("router", () => getRouterObject());
    }, 0);
}
window.onpopstate = history["onpushstate"] = function (e) { updateStoreBrowserHistory(); };
function getRouterObject() {
    return {
        location: location.pathname,
        query: Query_1.Query.get()
    };
}
exports.getRouterObject = getRouterObject;

});
___scope___.file("Query.js", function(exports, require, module, __filename, __dirname){

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class Query {
    static parse(url) {
        const split = url.split(/\?/);
        return {
            origin: split[0],
            query: split[1],
        };
    }
    static get(userURL) {
        // This function is anonymous, is executed immediately and
        // the return value is assigned to QueryString!
        var query_string = {};
        let url;
        if (userURL) {
            const parsed = this.parse(userURL);
            if (parsed.query === undefined) {
                return {};
            }
            url = parsed.query;
        }
        var query = url || window.location.search.substring(1);
        var vars = query.split("&");
        for (var i = 0; i < vars.length; i++) {
            var pair = vars[i].split("=");
            // If first entry with this name
            if (typeof query_string[pair[0]] === "undefined") {
                if (pair[0]) {
                    query_string[pair[0]] = decodeURIComponent(pair[1]);
                }
                // If second entry with this name
            }
            else if (typeof query_string[pair[0]] === "string") {
                var arr = [query_string[pair[0]], decodeURIComponent(pair[1])];
                query_string[pair[0]] = arr;
                // If third or later entry with this name
            }
            else {
                query_string[pair[0]].push(decodeURIComponent(pair[1]));
            }
        }
        return query_string;
    }
    static createString(data) {
        var stringData = [];
        for (const key in data) {
            stringData.push(key + "=" + encodeURI(data[key]));
        }
        var str = stringData.join("&");
        if (stringData.length > 0) {
            str = "?" + str;
        }
        return str;
    }
    static merge(input, userURL) {
        const current = this.get(userURL);
        for (const key in input) {
            if (input[key] === undefined) {
                delete current[key];
            }
            else {
                current[key] = input[key];
            }
        }
        const response = { str: this.createString(current), obj: current };
        if (userURL) {
            const parsed = this.parse(userURL);
            response.origin = parsed.origin;
            response.url = `${parsed.origin}${response.str}`;
        }
        return response;
    }
}
exports.Query = Query;

});
___scope___.file("Router/Link.js", function(exports, require, module, __filename, __dirname){

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const React = require("react");
const Fusion_1 = require("../Fusion");
const Store_1 = require("../Store");
const Utils_1 = require("../Utils");
const Query_1 = require("../Query");
let Link = class Link extends Fusion_1.Fusion {
    navigate() {
        const path = this.props.to;
        window.history.pushState({}, "", path);
        Store_1.dispatch("router", () => ({
            location: path,
            query: Query_1.Query.get()
        }));
    }
    linkClicked(e) {
        e.preventDefault();
        if (this.props.onClick) {
            this.props.onClick(e);
        }
        this.navigate();
    }
    render() {
        let toLink = this.props.match || this.props.to;
        if (!this.props.exact) {
            toLink += "(.*)";
        }
        const matched = Utils_1.pathMatch(this.store.router.location, toLink);
        if (this.props.render) {
            return this.props.render(matched !== undefined, () => this.navigate());
        }
        else {
            const classes = [];
            if (this.props.className) {
                classes.push(this.props.className);
            }
            if (matched && this.props.activeClassName) {
                classes.push(this.props.activeClassName);
            }
            return React.createElement("a", { className: classes.join(' '), onClick: e => this.linkClicked(e), href: this.props.to }, this.props.children);
        }
    }
};
Link = tslib_1.__decorate([
    Store_1.connect('@router')
], Link);
exports.Link = Link;

});
___scope___.file("Utils.js", function(exports, require, module, __filename, __dirname){

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const pathToRegexp = require("path-to-regexp");
function pathMatch(location, path) {
    const keys = [];
    const re = pathToRegexp(path, keys);
    let matched = re.exec(location);
    if (matched) {
        const params = {};
        for (let k = 0; k < keys.length; k++) {
            let item = keys[k];
            params[item.name] = matched[k + 1];
        }
        return params;
    }
}
exports.pathMatch = pathMatch;
function classProp(...any) {
    return { className: cls.apply(undefined, arguments) };
}
exports.classProp = classProp;
function cls(...any) {
    let clsNames = [];
    const args = arguments;
    for (const i in arguments) {
        const arg = arguments[i];
        if (typeof arg === "string") {
            clsNames.push(arg);
        }
        else {
            if (Array.isArray(arg)) {
                arg.forEach(a => clsNames.push(a));
            }
            else {
                if (typeof arg === "object") {
                    for (const key in arg) {
                        if (arg[key]) {
                            clsNames.push(key);
                        }
                    }
                }
            }
        }
    }
    return clsNames.join(" ");
}
exports.cls = cls;

});
___scope___.file("Router/Switch.js", function(exports, require, module, __filename, __dirname){

"use strict";
const tslib_2 = require("tslib");
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const React = require("react");
const Fusion_1 = require("../Fusion");
const Route_1 = require("./Route");
const Utils_1 = require("../Utils");
const Store_1 = require("../Store");
let Switch = class Switch extends Fusion_1.Fusion {
    init() {
        if (this.props.config) {
            this.renderConfig();
        }
        else {
            this.renderChildren();
        }
    }
    findItem(items) {
        for (let i = 0; i < items.length; i++) {
            const item = items[i];
            let match = item.path;
            if (!item.exact) {
                match += "(.*)";
            }
            const location = this.store.router.location;
            const params = Utils_1.pathMatch(location, match);
            if (params) {
                return {
                    item,
                    params
                };
            }
        }
    }
    resetAll() {
        this.setState({
            placeholder: undefined,
            componentChildren: undefined,
            component: undefined,
            props: undefined,
            validReactComponent: undefined
        });
    }
    evaluteFunctionResult(fnResult, match) {
        if (React.isValidElement(fnResult)) {
            if (this.state.validReactComponent !== fnResult) {
                return this.isComponentMounted && this.setState({ validReactComponent: fnResult, component: undefined });
            }
            return;
        }
        let targetComponent = fnResult;
        if (!React.Component.isPrototypeOf(targetComponent)) {
            targetComponent = fnResult.default;
            if (!React.Component.isPrototypeOf(targetComponent)) {
                const firstKey = Object.keys(fnResult)[0];
                targetComponent = fnResult[firstKey];
                if (!React.Component.isPrototypeOf(targetComponent)) {
                    throw new Error("Suitable component was not found while loading an async router.");
                }
            }
        }
        if (this.state.component !== targetComponent) {
            this.isComponentMounted &&
                this.setState({
                    validReactComponent: undefined,
                    component: targetComponent,
                    props: { match: match }
                });
        }
    }
    renderItems(items) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            const foundItem = this.findItem(items);
            if (!foundItem) {
                return this.resetAll();
            }
            const { item, params } = foundItem;
            const location = this.store.router.location;
            if (item.children) {
                return this.setState({ componentChildren: item.children });
            }
            if (item.component) {
                const match = {
                    params: params,
                    location: location,
                    path: item.path
                };
                if (React.Component.isPrototypeOf(item.component)) {
                    if (this.state.component !== item.component) {
                        return (this.isComponentMounted &&
                            this.setState({
                                validReactComponent: undefined,
                                component: item.component,
                                props: { match: match }
                            }));
                    }
                    return;
                }
                if (typeof item.component === "function") {
                    this.resetAll();
                    if (this.props.placeholder) {
                        this.setState({ placeholder: this.props.placeholder });
                    }
                    const fnResult = yield item.component(match);
                    return this.evaluteFunctionResult(fnResult, match);
                }
            }
        });
    }
    renderChildren() {
        const children = [].concat(this.props.children);
        const items = [];
        for (let i = 0; i < children.length; i++) {
            const item = children[i];
            if (item.type !== Route_1.Route) {
                throw new Error("Children of Switch must have only Route object");
            }
            items.push({
                path: item.props.path,
                exact: item.props.exact,
                component: item.props.component,
                children: item.props.children
            });
        }
        return this.renderItems(items);
    }
    renderConfig() {
        const items = [];
        for (const path in this.props.config.routes) {
            const item = this.props.config.routes[path];
            items.push({
                path: path,
                exact: item.exact,
                component: item.component
            });
        }
        return this.renderItems(items);
    }
    render() {
        if (this.state.componentChildren) {
            return this.state.componentChildren;
        }
        const Component = this.state.component;
        if (this.state.validReactComponent) {
            return this.state.validReactComponent;
        }
        if (Component) {
            return React.createElement(Component, Object.assign({}, this.state.props));
        }
        if (this.state.placeholder) {
            return this.state.placeholder;
        }
        return React.createElement("span", null);
    }
};
Switch = tslib_1.__decorate([
    Store_1.connect("@router")
], Switch);
exports.Switch = Switch;
//# sourceMappingURL=Switch.js.map
});
return ___scope___.entry = "index.js";
});